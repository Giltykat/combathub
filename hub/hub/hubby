game:GetService("Players").LocalPlayer.OnTeleport:Connect(function(state)
    if state == Enum.TeleportState.InProgress then
        -- Show a message before teleporting
        messagebox("Rejoining!", "Combathub", 0)

        task.wait(4) -- Wait 4 seconds before proceeding

        -- Execute the script after the delay
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Giltykat/combathub-public-nosource/refs/heads/main/hub.lua"))()
    end
end)


local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Combat Hub",
    Icon = skull, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Booting Scripts",
    LoadingSubtitle = "by GiltyKat",
    Theme = "DarkBlue", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = true,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = Minhub, -- Create a custom folder for your hub/game
       FileName = "Min Hub"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = true, -- Set this to true to use our key system
    KeySettings = {
       Title = "Security Init",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"1234"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

 local vis = Window:CreateTab("Visuals", "view") -- Title, Image
 local aim = Window:CreateTab("Aim", "crosshair") -- Title, Image
 local con = Window:CreateTab("Config", "view") -- Title, Image
 local mis = Window:CreateTab("Misc", "chevron-last") -- Title, Image
 local wor = Window:CreateTab("World", "earth") -- Title, Image

 local Toggle = vis:CreateToggle({
    Name = "Skeleton Esp",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Universal Bones ESP with Proper Rotation and Length
-- This script ensures ESP lines match the exact rotation and length of limbs.

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local DrawingLines = {}

-- Function to create a line
local function createLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = Color3.new(1, 0, 0) -- Red
    line.Thickness = 2
    return line
end

-- Function to update lines for a single player
local function updatePlayerESP(player)
    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
        local character = player.Character
        local bodyParts = {
            Head = character:FindFirstChild("Head"),
            Torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
            LeftArm = character:FindFirstChild("LeftUpperArm") or character:FindFirstChild("Left Arm"),
            RightArm = character:FindFirstChild("RightUpperArm") or character:FindFirstChild("Right Arm"),
            LeftLeg = character:FindFirstChild("LeftUpperLeg") or character:FindFirstChild("Left Leg"),
            RightLeg = character:FindFirstChild("RightUpperLeg") or character:FindFirstChild("Right Leg"),
        }

        local bones = {
            {bodyParts.Head, bodyParts.Torso},
            {bodyParts.Torso, bodyParts.LeftArm},
            {bodyParts.Torso, bodyParts.RightArm},
            {bodyParts.Torso, bodyParts.LeftLeg},
            {bodyParts.Torso, bodyParts.RightLeg},
        }

        for index, bone in ipairs(bones) do
            local part1, part2 = bone[1], bone[2]
            local line = DrawingLines[player.Name .. index] or createLine()
            DrawingLines[player.Name .. index] = line

            if part1 and part2 then
                -- Calculate the midpoint of the limb for more accuracy
                local part1Pos, part1Visible = Camera:WorldToViewportPoint(part1.Position)
                local part2Pos, part2Visible = Camera:WorldToViewportPoint(part2.Position)

                if part1Visible and part2Visible then
                    line.Visible = true
                    line.From = Vector2.new(part1Pos.X, part1Pos.Y)
                    line.To = Vector2.new(part2Pos.X, part2Pos.Y)
                else
                    line.Visible = false
                end
            else
                line.Visible = false
            end
        end
    else
        -- Hide lines if player is invalid
        for index = 1, 5 do
            local line = DrawingLines[player.Name .. index]
            if line then
                line.Visible = false
            end
        end
    end
end

-- Function to update ESP for all players
local function updateESP()
    for _, player in ipairs(Players:GetPlayers()) do
        updatePlayerESP(player)
    end
end

-- Clean up lines when player leaves
Players.PlayerRemoving:Connect(function(player)
    for index = 1, 5 do
        local line = DrawingLines[player.Name .. index]
        if line then
            line:Remove()
            DrawingLines[player.Name .. index] = nil
        end
    end
end)

-- Run the ESP update
RunService.RenderStepped:Connect(updateESP)

    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Snaplines",
    CurrentValue = false,
    Flag = "Toggle2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Universal Snapline ESP with Toggle & Rainbow Option

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Configuration Variables  -- Default line color (Green)
local RainbowSnaplines = RainbowSnaplineC                -- Set to true for rainbow snaplines
local RainbowSpeed = SnaplineRainbowC                      -- Multiplier for rainbow speed (adjust as desired)

-- Persistent globals for toggling
_G.isSnaplineESPEnabled = _G.isSnaplineESPEnabled or false
if _G.snaplineESPConnection then
    _G.snaplineESPConnection:Disconnect()
    _G.snaplineESPConnection = nil
end

-- Table to store active Drawing lines
local DrawingLines = {}

-- Function to create a new line using Drawing
local function createLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = SnaplinesCconfig
    line.Thickness = 2
    return line
end

-- Function to update the snapline for a specific player
local function updatePlayerSnapline(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return
    end

    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid.Health <= 0 then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local line = DrawingLines[player.Name] or createLine()
    DrawingLines[player.Name] = line

    local rootPosition, visible = Camera:WorldToViewportPoint(rootPart.Position)
    local screenSize = Camera.ViewportSize
    local bottomMiddle = Vector2.new(screenSize.X / 2, screenSize.Y)

    if visible then
        line.Visible = true
        line.From = bottomMiddle
        line.To = Vector2.new(rootPosition.X, rootPosition.Y)
        if RainbowSnaplines then
            local hue = (tick() * RainbowSpeed) % 1
            line.Color = Color3.fromHSV(hue, 1, 1)
        else
            line.Color = SnaplinesCconfig
        end
    else
        line.Visible = false
    end
end

-- Function to update snaplines for all players
local function updateSnaplines()
    for _, player in ipairs(Players:GetPlayers()) do
        updatePlayerSnapline(player)
    end
end

-- Clean up lines when a player leaves
Players.PlayerRemoving:Connect(function(player)
    local line = DrawingLines[player.Name]
    if line then
        line:Remove()
        DrawingLines[player.Name] = nil
    end
end)

---------------------------------------------------
-- Toggle Functions
---------------------------------------------------

-- Enable Snapline ESP
local function enableSnaplines()
    _G.snaplineESPConnection = RunService.RenderStepped:Connect(updateSnaplines)
    _G.isSnaplineESPEnabled = true
    print("Snapline ESP enabled")
end

-- Disable Snapline ESP
local function disableSnaplines()
    if _G.snaplineESPConnection then
        _G.snaplineESPConnection:Disconnect()
        _G.snaplineESPConnection = nil
    end
    for name, line in pairs(DrawingLines) do
        if line then
            line:Remove()
            DrawingLines[name] = nil
        end
    end
    _G.isSnaplineESPEnabled = false
    print("Snapline ESP disabled")
end

-- Toggle function for Snapline ESP
local function toggleSnaplines()
    if _G.isSnaplineESPEnabled then
        disableSnaplines()
    else
        enableSnaplines()
    end
end

-- Run toggle on script execution
toggleSnaplines()


    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Radar",
    CurrentValue = false,
    Flag = "Toggle3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Universal Radar ESP
-- Creates a top-down radar displaying player positions relative to the local player.

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Variables
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RadarRadius = 100 -- Radius of the radar in pixels
local RadarCenter = Vector2.new(200, 200) -- Center of the radar on the screen
local RadarScale = 1 / 10 -- Scale for converting world distances to radar distances
local RadarDots = {}

-- Function to create a radar dot
local function createDot()
    local dot = Drawing.new("Circle")
    dot.Visible = false
    dot.Color = Color3.new(1, 0, 0) -- Red
    dot.Radius = 3
    dot.Filled = true
    return dot
end

-- Function to update radar for a player
local function updatePlayerRadar(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return
    end

    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")

    -- Skip players with no health
    if humanoid.Health <= 0 then
        return
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return
    end

    local dot = RadarDots[player.Name] or createDot()
    RadarDots[player.Name] = dot

    -- Calculate the position of the player relative to the local player
    local localRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localRootPart then
        dot.Visible = false
        return
    end

    local relativePosition = rootPart.Position - localRootPart.Position
    local radarPosition = Vector2.new(relativePosition.X, relativePosition.Z) * RadarScale

    -- Check if the player is within the radar radius
    if radarPosition.Magnitude <= RadarRadius then
        dot.Visible = true
        dot.Position = RadarCenter + radarPosition
    else
        dot.Visible = false
    end
end

-- Function to update radar for all players
local function updateRadar()
    for _, player in ipairs(Players:GetPlayers()) do
        updatePlayerRadar(player)
    end
end

-- Clean up dots when a player leaves
Players.PlayerRemoving:Connect(function(player)
    local dot = RadarDots[player.Name]
    if dot then
        dot:Remove()
        RadarDots[player.Name] = nil
    end
end)

-- Radar Border
local radarBorder = Drawing.new("Circle")
radarBorder.Visible = true
radarBorder.Color = Color3.new(0, 1, 0) -- Green
radarBorder.Thickness = 2
radarBorder.Filled = false
radarBorder.Position = RadarCenter
radarBorder.Radius = RadarRadius

-- Render update
RunService.RenderStepped:Connect(function()
    updateRadar()
end)

    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Tool Esp",
    CurrentValue = false,
    Flag = "Toggle4", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Persistent globals for toggling and connection storage
_G.isToolESPEnabled = _G.isToolESPEnabled or false
if _G.toolESPConnection then
    _G.toolESPConnection:Disconnect()
    _G.toolESPConnection = nil
end

-- Helper: Remove existing Tool ESP labels from all players
local function removeToolESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local esp = head:FindFirstChild("ToolESP")
            if esp then
                esp:Destroy()
            end
        end
    end
end

-- Update Tool ESP for all players every frame
local function updateToolESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local toolName = "None"
            -- Look for an equipped tool (Tools are parented to the character)
            for _, child in ipairs(player.Character:GetChildren()) do
                if child:IsA("Tool") then
                    toolName = child.Name
                    break
                end
            end

            local billboard = head:FindFirstChild("ToolESP")
            if not billboard then
                billboard = Instance.new("BillboardGui")
                billboard.Name = "ToolESP"
                billboard.Adornee = head
                billboard.Size = UDim2.new(0, 150, 0, 50)
                billboard.StudsOffset = Vector3.new(0, 2, 0)
                billboard.AlwaysOnTop = true

                local label = Instance.new("TextLabel", billboard)
                label.Name = "TextLabel"
                label.Size = UDim2.new(1, 0, 1, 0)
                label.BackgroundTransparency = 1
                label.TextScaled = true
                label.TextColor3 = Color3.new(1, 1, 1)
                label.Font = Enum.Font.SourceSansBold

                billboard.Parent = head
            end
            if billboard:FindFirstChild("TextLabel") then
                billboard.TextLabel.Text = toolName
            end
        end
    end
end

-- Toggle function: Enables or disables the Tool ESP update loop.
local function toggleToolESP()
    _G.isToolESPEnabled = not _G.isToolESPEnabled
    if _G.isToolESPEnabled then
        _G.toolESPConnection = RunService.RenderStepped:Connect(function()
            updateToolESP()
        end)
        print("Tool ESP enabled")
    else
        if _G.toolESPConnection then
            _G.toolESPConnection:Disconnect()
            _G.toolESPConnection = nil
        end
        removeToolESP()
        print("Tool ESP disabled")
    end
end

toggleToolESP()  -- Toggle the ESP mode on script execution


    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Name esp",
    CurrentValue = false,
    Flag = "Toggle5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Name ESP
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local NameESPTexts = {}

local function createText()
    local text = Drawing.new("Text")
    text.Visible = false
    text.Size = 20
    text.Color = Color3.new(1, 1, 1) -- White
    text.Center = true
    return text
end

local function updateNameESP(player)
    if player == Players.LocalPlayer or not player.Character then
        return
    end

    local character = player.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

    local text = NameESPTexts[player.Name] or createText()
    NameESPTexts[player.Name] = text

    if humanoidRootPart then
        local screenPosition, visible = Camera:WorldToViewportPoint(humanoidRootPart.Position)
        if visible then
            text.Visible = true
            text.Text = player.Name
            text.Position = Vector2.new(screenPosition.X, screenPosition.Y - 40)
        else
            text.Visible = false
        end
    else
        text.Visible = false
    end
end

RunService.RenderStepped:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        updateNameESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if NameESPTexts[player.Name] then
        NameESPTexts[player.Name]:Remove()
        NameESPTexts[player.Name] = nil
    end
end)

    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Health Esp",
    CurrentValue = false,
    Flag = "Toggle6", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local Camera = workspace.CurrentCamera
        
        -- Configuration options for the Health ESP
        local HealthESPConfig = {
            ShowText = false,         -- Set to true to display health text (e.g., "100 HP")
            ShowBar = true,           -- Set to true to display the health bar
            BarWidth = 50,            -- Width of the health bar
            BarHeight = 5,            -- Height of the health bar
            BarColor = HealthEspColorCon,          -- Color of the health fill (green by default)
            BarBackgroundColor = Color3.new(0, 0, 0),  -- Background color of the health bar
        }
        
        -- Container for ESP elements for each player
        local HealthESPElements = {}
        
        -- Creates the ESP drawings for a player based on config options
        local function createHealthESP(player)
            local elements = {}
            if HealthESPConfig.ShowBar then
                elements.BarBackground = Drawing.new("Square")
                elements.BarBackground.Visible = false
                elements.BarBackground.Filled = true
                elements.BarBackground.Color = HealthESPConfig.BarBackgroundColor
                elements.BarBackground.Transparency = 0.5
                elements.BarBackground.ZIndex = 1
        
                elements.BarFill = Drawing.new("Square")
                elements.BarFill.Visible = false
                elements.BarFill.Filled = true
                elements.BarFill.Color = HealthESPConfig.BarColor
                elements.BarFill.ZIndex = 2
            end
            if HealthESPConfig.ShowText then
                elements.Text = Drawing.new("Text")
                elements.Text.Visible = false
                elements.Text.Size = 20
                elements.Text.Color = HealthESPConfig.BarColor
                elements.Text.Center = true
                elements.Text.ZIndex = 3
            end
            return elements
        end
        
        -- Updates the ESP for a given player
        local function updateHealthESP(player)
            if player == Players.LocalPlayer or not player.Character then
                return
            end
        
            local character = player.Character
            local humanoid = character:FindFirstChild("Humanoid")
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if not humanoid or not humanoidRootPart then
                return
            end
        
            local screenPosition, visible = Camera:WorldToViewportPoint(humanoidRootPart.Position)
            local elements = HealthESPElements[player.Name] or createHealthESP(player)
            HealthESPElements[player.Name] = elements
        
            if visible then
                if HealthESPConfig.ShowBar then
                    local barX = screenPosition.X - HealthESPConfig.BarWidth / 2
                    local barY = screenPosition.Y - 60  -- Adjust vertical offset as needed
                    elements.BarBackground.Visible = true
                    elements.BarBackground.Position = Vector2.new(barX, barY)
                    elements.BarBackground.Size = Vector2.new(HealthESPConfig.BarWidth, HealthESPConfig.BarHeight)
                    
                    local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                    elements.BarFill.Visible = true
                    elements.BarFill.Position = Vector2.new(barX, barY)
                    elements.BarFill.Size = Vector2.new(HealthESPConfig.BarWidth * healthPercent, HealthESPConfig.BarHeight)
                end
                
                if HealthESPConfig.ShowText and elements.Text then
                    elements.Text.Visible = true
                    elements.Text.Text = tostring(math.floor(humanoid.Health)) .. " HP"
                    elements.Text.Position = Vector2.new(screenPosition.X, screenPosition.Y - 70)
                elseif elements.Text then
                    elements.Text.Visible = false
                end
            else
                if elements.BarBackground then elements.BarBackground.Visible = false end
                if elements.BarFill then elements.BarFill.Visible = false end
                if elements.Text then elements.Text.Visible = false end
            end
        end
        
        -- Update ESP every frame
        RunService.RenderStepped:Connect(function()
            for _, player in ipairs(Players:GetPlayers()) do
                updateHealthESP(player)
            end
        end)
        
        -- Clean up ESP elements when a player leaves
        Players.PlayerRemoving:Connect(function(player)
            local elements = HealthESPElements[player.Name]
            if elements then
                for _, drawing in pairs(elements) do
                    drawing:Remove()
                end
                HealthESPElements[player.Name] = nil
            end
        end)
        

    end,
 })

 local Paragraph = aim:CreateParagraph({Title = "!Important!", Content = "Set your configaration before you start the aimbot"})

 local Toggle = aim:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "Toggle7", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")
        local Camera = workspace.CurrentCamera
        
        -- Settings
        local AimbotSettings = {
            FOV = editfov, -- Field of View size
            Smoothness = smoothness, -- Smoothing factor (0 = instant, higher = slower)
            AimKey = AimkeyCon, -- Key to activate aimbot
            FOVColor = FOVCconfig, -- FOV circle color
            FOVTransparency = 0.5, -- FOV circle transparency
            FOVVisible = FovIsVisible, -- Show/hide FOV circle (1 = show, 0 = hide)
            TeamCheck = AIMTEAMCHECK, -- Enable/disable team check
            VisibilityCheck = AIMVISIBILITYCHECK, -- Enable/disable visibility check
        }
        
        -- Variables
        local FOVCircle = Drawing.new("Circle")
        local AimingAt = nil
        local IsAiming = false
        
        -- Initialize FOV circle
        FOVCircle.Visible = (AimbotSettings.FOVVisible == 1)
        FOVCircle.Color = AimbotSettings.FOVColor
        FOVCircle.Thickness = 2
        FOVCircle.Transparency = AimbotSettings.FOVTransparency
        FOVCircle.Radius = AimbotSettings.FOV
        FOVCircle.Filled = false
        
        -- Function to check if a target is visible (Raycast check)
        local function isTargetVisible(targetPart)
            if not AimbotSettings.VisibilityCheck then
                return true -- Skip visibility check if disabled
            end
        
            local origin = Camera.CFrame.Position
            local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {Players.LocalPlayer.Character}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        
            local result = workspace:Raycast(origin, direction, raycastParams)
            return result == nil or result.Instance == targetPart
        end
        
        -- Function to get closest valid target within FOV
        local function getClosestPlayer()
            local closestPlayer = nil
            local shortestDistance = AimbotSettings.FOV
        
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                    if AimbotSettings.TeamCheck and player.Team and Players.LocalPlayer.Team and player.Team == Players.LocalPlayer.Team then
                        -- Skip teammates if team check is enabled
                    else
                        local head = player.Character.Head
                        local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
        
                        if onScreen and isTargetVisible(head) then
                            local mousePos = UserInputService:GetMouseLocation()
                            local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        
                            if distance < shortestDistance then
                                closestPlayer = player
                                shortestDistance = distance
                            end
                        end
                    end
                end
            end
        
            return closestPlayer
        end
        
        -- Function to smoothly aim at a target
        local function aimAt(target)
            if not target or not target.Character or not target.Character:FindFirstChild("Head") then
                return
            end
        
            local head = target.Character.Head
            local targetPos = Camera:WorldToViewportPoint(head.Position)
            local mousePos = UserInputService:GetMouseLocation()
        
            -- Smooth aim movement
            local deltaX = (targetPos.X - mousePos.X) * AimbotSettings.Smoothness
            local deltaY = (targetPos.Y - mousePos.Y) * AimbotSettings.Smoothness
        
            -- Move the mouse
            mousemoverel(deltaX, deltaY)
        end
        
        -- Update FOV circle position & radius dynamically
        RunService.RenderStepped:Connect(function()
            local mousePos = UserInputService:GetMouseLocation()
            FOVCircle.Position = mousePos
        
            if FOVCircle.Radius ~= AimbotSettings.FOV then
                FOVCircle.Radius = AimbotSettings.FOV
            end
        end)
        
        -- Main aimbot loop
        RunService.RenderStepped:Connect(function()
            if IsAiming then
                if not AimingAt or not AimingAt.Character or not AimingAt.Character:FindFirstChild("Head") then
                    AimingAt = getClosestPlayer()
                end
        
                if AimingAt then
                    aimAt(AimingAt)
                end
            else
                AimingAt = nil
            end
        end)
        
        -- Listen for aim key input
        UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == AimbotSettings.AimKey then
                IsAiming = true
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == AimbotSettings.AimKey then
                IsAiming = false
            end
        end)
        
        -- Toggle FOV visibility
        FOVCircle.Visible = (AimbotSettings.FOVVisible == 1)
        
        
    end,
 })




 local Toggle = mis:CreateToggle({
    Name = "Wireframe World",
    CurrentValue = false,
    Flag = "Toggle8", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        local Players = game:GetService("Players")

        -- Use _G to persist state across script executions
        _G.isWireframeEnabled = _G.isWireframeEnabled or false
        _G.originalWireframeProperties = _G.originalWireframeProperties or {}
        
        -- Helper: determine if a part is inside a player character model
        local function isPlayerCharacter(part)
            local model = part:FindFirstAncestorOfClass("Model")
            if model and model:FindFirstChildWhichIsA("Humanoid") then
                return true
            end
            return false
        end
        
        -- Enable wireframe: iterate all BaseParts (except those in player characters)
        local function enableWireframe()
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("BasePart") and not isPlayerCharacter(obj) then
                    -- Store original properties if not already stored
                    if not _G.originalWireframeProperties[obj] then
                        _G.originalWireframeProperties[obj] = {
                            Transparency = obj.Transparency,
                            Material = obj.Material,
                            Color = obj.Color
                        }
                    end
                    
                    -- Make the actual part invisible
                    obj.Transparency = 1
                    
                    -- Remove any existing SelectionBox to avoid duplicates
                    local existingSB = obj:FindFirstChild("WireframeSelectionBox")
                    if existingSB then
                        existingSB:Destroy()
                    end
                    
                    -- Create a SelectionBox to serve as the wireframe outline
                    local selectionBox = Instance.new("SelectionBox")
                    selectionBox.Name = "WireframeSelectionBox"
                    selectionBox.Adornee = obj
                    selectionBox.LineThickness = 0.05  -- Adjust for desired line weight
                    -- Use the original part color (or change to a fixed color if preferred)
                    selectionBox.Color3 = _G.originalWireframeProperties[obj].Color or Color3.new(1, 1, 1)
                    selectionBox.Parent = obj
                end
            end
            _G.isWireframeEnabled = true
            print("Wireframe mode enabled")
        end
        
        -- Disable wireframe: restore original properties and remove SelectionBoxes
        local function disableWireframe()
            for part, props in pairs(_G.originalWireframeProperties) do
                if part and part.Parent then
                    part.Transparency = props.Transparency
                    part.Material = props.Material
                    part.Color = props.Color
                    local selectionBox = part:FindFirstChild("WireframeSelectionBox")
                    if selectionBox then
                        selectionBox:Destroy()
                    end
                end
            end
            -- Clear our stored properties
            _G.originalWireframeProperties = {}
            _G.isWireframeEnabled = false
            print("Wireframe mode disabled")
        end
        
        -- Toggle wireframe state
        local function toggleWireframe()
            if _G.isWireframeEnabled then
                disableWireframe()
            else
                enableWireframe()
            end
        end
        
        toggleWireframe()
        
        
    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Npc Snaplines",
    CurrentValue = false,
    Flag = "Toggle9", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Place this script in a LocalScript (e.g., StarterPlayerScripts).
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Function to create a BillboardGui for displaying name and distance
local function createInfoLabel(object)
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "InfoLabel"
    billboardGui.Adornee = object
    billboardGui.Size = UDim2.new(4, 0, 2, 0) -- Adjust size as needed
    billboardGui.StudsOffset = Vector3.new(0, 3, 0) -- Position above the object
    billboardGui.AlwaysOnTop = true
    billboardGui.MaxDistance = 0 -- Ensures it remains the same size regardless of distance

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 0.5, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Text = object.Name
    textLabel.Parent = billboardGui

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.TextColor3 = Color3.new(1, 1, 1)
    distanceLabel.TextStrokeTransparency = 0.5
    distanceLabel.TextScaled = true
    distanceLabel.Font = Enum.Font.GothamBold
    distanceLabel.Parent = billboardGui

    return billboardGui, textLabel, distanceLabel
end

-- Function to create snap lines for humanoids
local function createSnapLine()
    local line = Drawing.new("Line")
    line.Color = Color3.new(1, 0, 0) -- Red color
    line.Thickness = 2
    line.Visible = true
    return line
end

-- Table to track active snap lines
local activeSnapLines = {}

-- Update ESP for each object in Workspace
local function updateObjectESP()
    for _, object in ipairs(Workspace:GetChildren()) do
        if object:IsA("BasePart") and string.find(object.Name:lower(), "container") then
            local billboardGui = object:FindFirstChild("InfoLabel")

            if not billboardGui then
                local newBillboardGui, textLabel, distanceLabel = createInfoLabel(object)
                newBillboardGui.Parent = object
                billboardGui = newBillboardGui
            end

            local distance = (object.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            billboardGui.TextLabel.Text = object.Name
            billboardGui.TextLabel.Parent.TextLabel.Text = string.format("%.1f studs", distance)
        end
    end
end

-- Update snap lines for humanoids in Workspace.AiZones
local function updateSnapLines()
    -- Clear previous snap lines
    for _, line in pairs(activeSnapLines) do
        line:Remove()
    end
    activeSnapLines = {}

    for _, zone in ipairs(Workspace:FindFirstChild("AiZones"):GetChildren()) do
        for _, object in ipairs(zone:GetChildren()) do
            if object:FindFirstChild("Humanoid") and object:FindFirstChild("HumanoidRootPart") then
                local humanoidRootPart = object.HumanoidRootPart

                -- Create and update snap line
                local line = createSnapLine()
                table.insert(activeSnapLines, line)

                local screenPosition, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y) -- Bottom center of the screen
                    line.To = Vector2.new(screenPosition.X, screenPosition.Y)
                    line.Visible = true
                else
                    line.Visible = false
                end
            end
        end
    end
end

-- Remove ESP if an object is removed
local function onObjectRemoving(object)
    local infoLabel = object:FindFirstChild("InfoLabel")
    if infoLabel then
        infoLabel:Destroy()
    end
end

-- Setup connections and update ESP every 30 seconds
for _, object in ipairs(Workspace:GetChildren()) do
    if object:IsA("BasePart") and string.find(object.Name:lower(), "container") then
        object.AncestryChanged:Connect(function()
            if not object:IsDescendantOf(Workspace) then
                onObjectRemoving(object)
            end
        end)
    end
end

RunService.RenderStepped:Connect(function()
    updateObjectESP()
    updateSnapLines()
end)

    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Distance esp",
    CurrentValue = false,
    Flag = "Toggle10", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Place this script in a LocalScript (e.g., StarterPlayerScripts).
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")


local function createDistanceLabel(character)
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "DistanceLabel"
    billboardGui.Adornee = character:WaitForChild("HumanoidRootPart")
    billboardGui.Size = UDim2.new(8, 0, 2, 0) -- Adjust size as needed
    billboardGui.StudsOffset = Vector3.new(0, -2.5, 0) -- Position below character
    billboardGui.AlwaysOnTop = true
    billboardGui.MaxDistance = 0 -- Ensures it remains the same size regardless of distance
    billboardGui.SizeOffset = Vector2.new(0, 0) -- Prevents scaling with distance

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Parent = billboardGui

    return billboardGui, textLabel
end

-- Update ESP for each player
local function updateESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local billboardGui = character:FindFirstChild("DistanceLabel")

            if not billboardGui then
                local newBillboardGui, textLabel = createDistanceLabel(character)
                newBillboardGui.Parent = character
                billboardGui = newBillboardGui
            end

            local humanoidRootPart = character.HumanoidRootPart
            local distance = (humanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            billboardGui.TextLabel.Text = string.format("%.1f studs", distance)
        end
    end
end

-- Remove ESP if a character is removed
local function onCharacterRemoving(character)
    local distanceLabel = character:FindFirstChild("DistanceLabel")
    if distanceLabel then
        distanceLabel:Destroy()
    end
end

-- Setup connections for ESP
local function setupPlayer(player)
    player.CharacterAdded:Connect(function(character)
        character:WaitForChild("HumanoidRootPart").GetPropertyChangedSignal("Position"):Connect(updateESP)
    end)
    player.CharacterRemoving:Connect(onCharacterRemoving)
end

-- Main loop
for _, player in ipairs(Players:GetPlayers()) do
    setupPlayer(player)
end

Players.PlayerAdded:Connect(setupPlayer)
RunService.RenderStepped:Connect(updateESP)

    end,
 })

walkSpeed = 50

 local Button = mis:CreateButton({
    Name = "Enable Walk Speed changer",
    Callback = function()
          -- Set the initial WalkSpeed here

        local function updatePlayerSpeed()
            -- Access the local player's character
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            
            -- Wait for the Humanoid to load
            local humanoid = character:WaitForChild("Humanoid")
            
            -- Continuously update the WalkSpeed
            while true do
                humanoid.WalkSpeed = walkSpeed
                wait(0.1)  -- Update every 0.1 seconds to prevent constant setting
            end
        end
        
        -- Call the function to start updating speed
        updatePlayerSpeed()
        
    end,
 })


 local Toggle = aim:CreateToggle({
    Name = "TriggerBot",
    CurrentValue = false,
    Flag = "Toggle11", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        local player = game:GetService("Players").LocalPlayer
        local mouse = player:GetMouse()
        local runService = game:GetService("RunService")
        local userInputService = game:GetService("UserInputService")
        
        -- Settings
        local TriggerBotSettings = {
            ButtonToHold = Enum.UserInputType.MouseButton2, -- Default: Right Mouse Button
            DelayTime = 0.1, -- Delay between mouse press and release
            TeamCheck = TRTEAMCHECK, -- Set to true to enable team check; false to disable
        }
        
        local buttonHeld = false
        
        -- Detect button press and release
        userInputService.InputBegan:Connect(function(input)
            if input.UserInputType == TriggerBotSettings.ButtonToHold then
                buttonHeld = true
            end
        end)
        
        userInputService.InputEnded:Connect(function(input)
            if input.UserInputType == TriggerBotSettings.ButtonToHold then
                buttonHeld = false
            end
        end)
        
        -- Main loop
        runService.RenderStepped:Connect(function()
            if buttonHeld and mouse.Target and mouse.Target.Parent:FindFirstChild("Humanoid") then
                local targetCharacter = mouse.Target.Parent
                local targetPlayer = game:GetService("Players"):GetPlayerFromCharacter(targetCharacter)
                
                -- If team check is enabled, ignore players on the same team
                if TriggerBotSettings.TeamCheck and targetPlayer and player.Team and targetPlayer.Team == player.Team then
                    return
                end
                
                if targetCharacter.Name ~= player.Name then
                    mouse1press()
                    wait(TriggerBotSettings.DelayTime)
                    mouse1release()
                end
            end
        end)
        
    
    end,
 })




 local Toggle = vis:CreateToggle({
    Name = "Skeleton Esp [R6 Rig Only]",
    CurrentValue = false,
    Flag = "Toggle12", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Configuration
local ESPSettings = {
    Enabled = true,
    LineColor = Color3.fromRGB(0, 255, 0), -- Bright green
    LineThickness = 2,
    Transparency = 1
}

-- Utility function to create lines
local function createLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = ESPSettings.LineColor
    line.Thickness = ESPSettings.LineThickness
    line.Transparency = ESPSettings.Transparency
    return line
end

-- Map body parts for skeleton
local SkeletonMap = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

-- Table to store player ESP lines
local ESPLines = {}

-- Update ESP for a player
local function updateESP(player)
    local character = player.Character
    if not character then return end

    for _, pair in ipairs(SkeletonMap) do
        local part0 = character:FindFirstChild(pair[1])
        local part1 = character:FindFirstChild(pair[2])

        if part0 and part1 and part0:IsA("BasePart") and part1:IsA("BasePart") then
            local line = ESPLines[player][pair] or createLine()

            local pos0, onScreen0 = Camera:WorldToViewportPoint(part0.Position)
            local pos1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)

            if onScreen0 and onScreen1 then
                line.Visible = ESPSettings.Enabled
                line.From = Vector2.new(pos0.X, pos0.Y)
                line.To = Vector2.new(pos1.X, pos1.Y)
            else
                line.Visible = false
            end

            ESPLines[player][pair] = line
        end
    end
end

-- Cleanup ESP lines for a player
local function cleanupESP(player)
    if ESPLines[player] then
        for _, line in pairs(ESPLines[player]) do
            line:Remove()
        end
        ESPLines[player] = nil
    end
end

-- Setup ESP for a player
local function setupESP(player)
    ESPLines[player] = {}

    player.CharacterAdded:Connect(function()
        cleanupESP(player)
        ESPLines[player] = {}
    end)

    player.CharacterRemoving:Connect(function()
        cleanupESP(player)
    end)
end

-- Initialize ESP for all players
local function initializeESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            setupESP(player)
        end
    end

    Players.PlayerAdded:Connect(function(player)
        setupESP(player)
    end)

    Players.PlayerRemoving:Connect(function(player)
        cleanupESP(player)
    end)
end

-- Main Render Loop
RunService.RenderStepped:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and ESPLines[player] then
            updateESP(player)
        end
    end
end)

-- Start the ESP system
initializeESP()

    end,
 })


 local Toggle = wor:CreateToggle({
    Name = "Fullbright",
    CurrentValue = false,
    Flag = "Toggle13", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Services
local Lighting = game:GetService("Lighting")

-- Use _G to persist state across script executions
_G.isFullbrightEnabled = _G.isFullbrightEnabled or false
_G.originalLightingProperties = _G.originalLightingProperties or {}

-- Function to enable fullbright
local function enableFullbright()
    -- Store original lighting settings if not already stored
    if not _G.originalLightingProperties.Ambient then
        _G.originalLightingProperties = {
            Ambient = Lighting.Ambient,
            OutdoorAmbient = Lighting.OutdoorAmbient,
            Brightness = Lighting.Brightness,
            ShadowSoftness = Lighting.ShadowSoftness,
            FogStart = Lighting.FogStart,
            FogEnd = Lighting.FogEnd
        }
    end

    -- Apply Fullbright settings
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)  -- Full brightness
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)  -- Full brightness outside
    Lighting.Brightness = 2  -- Increase brightness level
    Lighting.ShadowSoftness = 0  -- No shadows
    Lighting.FogStart = 0  -- Disable fog
    Lighting.FogEnd = 100000  -- Extend fog range to make it invisible

    _G.isFullbrightEnabled = true
    print("Fullbright enabled")
end

-- Function to disable fullbright (restore original settings)
local function disableFullbright()
    if _G.originalLightingProperties.Ambient then
        -- Restore original lighting properties
        Lighting.Ambient = _G.originalLightingProperties.Ambient
        Lighting.OutdoorAmbient = _G.originalLightingProperties.OutdoorAmbient
        Lighting.Brightness = _G.originalLightingProperties.Brightness
        Lighting.ShadowSoftness = _G.originalLightingProperties.ShadowSoftness
        Lighting.FogStart = _G.originalLightingProperties.FogStart
        Lighting.FogEnd = _G.originalLightingProperties.FogEnd
    end

    -- Clear stored properties
    _G.originalLightingProperties = {}
    _G.isFullbrightEnabled = false
    print("Fullbright disabled")
end

-- Toggle function
local function toggleFullbright()
    if _G.isFullbrightEnabled then
        disableFullbright()
    else
        enableFullbright()
    end
end

toggleFullbright() -- Run on script execution


    end,
 })

playerfov = 90

 local Slider = mis:CreateSlider({
    Name = "FOV",
    Range = {1, 300},
    Increment = 1,
    Suffix = "Degrees",
    CurrentValue = 90,
    Flag = "Slider5", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
playerfov = Value 
    end,
 })

 local Button = mis:CreateButton({
    Name = "Update Fov ",
    Callback = function()
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        
        -- The FOV variable  change this value as needed, or update it via another script or GUI.
        playerfov = 90
        
        -- Optionally, if you want to allow external scripts to change the FOV,
        -- you could store it in a global variable, e.g., _G.FOV
        
        -- Get the current camera (assuming this script runs on the client)
        local camera = workspace.CurrentCamera
        
        -- Constantly update the camera's FieldOfView every frame
        RunService.RenderStepped:Connect(function()
            if camera then
                camera.FieldOfView = playerfov
            end
        end)
        
        -- Example: Change the FOV after 5 seconds (for testing)
        delay(5, function()
            playerfov = 120
            print("FOV updated to 120")
        end)
        

    end,
 })

 local Button = mis:CreateButton({
    Name = "Rejoin Server",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        
        -- Get the local player
        local player = Players.LocalPlayer
        
        -- Retrieve the current game's PlaceId and the server's JobId
        local placeId = game.PlaceId
        local jobId = game.JobId
        
        -- Teleport the player to the same server instance (rejoin)
        TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
        
    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Chams",
    CurrentValue = false,
    Flag = "Toggle17", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
-- Configuration (set these variables as desired before running the script)
local selfchams = false         -- Set to true to apply the effect to your own character
local rainbowchams = true       -- Set to true to enable gradual rainbow color shifts
local rainbowspeed = 5          -- Time (in seconds) for one full rainbow cycle
local chamscolor = Color3.fromRGB(255, 0, 0)  -- Default color (red)

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Config assignments
local ApplyToSelf = selfchams
local ColorChangeEnabled = rainbowchams
local ColorChangeInterval = rainbowspeed
local DefaultColor = chamscolor

-- Persistent globals for toggling and storing original properties
_G.isChamsEnabled = _G.isChamsEnabled or false
_G.chamsData = _G.chamsData or {}  -- Stores original Material and Color for each modified BasePart

-----------------------------------------------------
-- Helper Functions
-----------------------------------------------------

-- Remove neon/chams effects from a character (restore original material/color and remove highlight)
local function removeChamsFromCharacter(character)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if _G.chamsData[part] then
                local orig = _G.chamsData[part]
                part.Material = orig.Material
                part.Color = orig.Color
                _G.chamsData[part] = nil
            end
            local highlight = part:FindFirstChild("NeonHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

-- Function to remove clothes (this is destructive; they cannot be restored on toggle off)
local function removeClothes(character)
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") or item:IsA("Accessory") then
            item:Destroy()
        end
    end
end

-----------------------------------------------------
-- Chams Application Functions
-----------------------------------------------------

-- Apply the neon chams effect to a character:
local function applyChams(character)
    removeClothes(character)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if not _G.chamsData[part] then
                _G.chamsData[part] = {
                    Material = part.Material,
                    Color = part.Color
                }
            end
            part.Material = Enum.Material.Neon
            part.Color = DefaultColor
        end
    end
    local highlight = Instance.new("Highlight")
    highlight.Name = "NeonHighlight"
    highlight.Adornee = character
    highlight.FillColor = DefaultColor
    highlight.FillTransparency = 1  -- fully transparent fill so details remain visible
    highlight.OutlineColor = DefaultColor
    highlight.OutlineTransparency = 0  -- visible outline
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character
end

-- Gradually update the chams to cycle through rainbow colors using HSV.
local function updateRainbowChams(character, startTime)
    if not ColorChangeEnabled then return end
    task.spawn(function()
        while character.Parent and _G.isChamsEnabled do
            local elapsed = tick() - startTime
            local hue = (elapsed / ColorChangeInterval) % 1
            local newColor = Color3.fromHSV(hue, 1, 1)
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Material == Enum.Material.Neon then
                    part.Color = newColor
                end
            end
            local highlight = character:FindFirstChild("NeonHighlight")
            if highlight then
                highlight.FillColor = newColor
                highlight.OutlineColor = newColor
            end
            task.wait(0.03)
        end
    end)
end

-----------------------------------------------------
-- Character & Player Handling
-----------------------------------------------------

-- Function to handle when a new character spawns
local function onCharacterAdded(character, player)
    if not ApplyToSelf and player == Players.LocalPlayer then return end
    applyChams(character)
    if ColorChangeEnabled then
        local startTime = tick()
        updateRainbowChams(character, startTime)
    end
end

-- Enable chams for all current and future players
local function enableChams()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            onCharacterAdded(player.Character, player)
        end
        player.CharacterAdded:Connect(function(character)
            onCharacterAdded(character, player)
        end)
    end
    _G.isChamsEnabled = true
    print("Chams enabled")
end

-- Disable chams for all players (restore original properties and remove highlights)
local function disableChams()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            removeChamsFromCharacter(player.Character)
        end
    end
    _G.chamsData = {}
    _G.isChamsEnabled = false
    print("Chams disabled")
end

-----------------------------------------------------
-- Toggle Function
-----------------------------------------------------

local function toggleChams()
    if _G.isChamsEnabled then
        disableChams()
    else
        enableChams()
    end
end

toggleChams()

        
    end,
 })

 local Toggle = vis:CreateToggle({
    Name = "Glow",
    CurrentValue = false,
    Flag = "Toggle18", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        
        -- Configuration
        local ApplyToSelf = false -- Set to true to apply effect to your own character
        local ColorChangeEnabled = false -- Set to true to enable gradual color shifts
        local ColorChangeInterval = 3 -- Time (seconds) between color changes
        local DefaultColor = Color3.fromRGB(255, 0, 0) -- Bright Red
        
        -- Function to remove clothes
        local function removeClothes(character)
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Shirt") or item:IsA("Pants") or item:IsA("ShirtGraphic") or item:IsA("Accessory") then
                    item:Destroy()
                end
            end
        end
        
        -- Function to apply neon effect
        local function applyNeonEffect(character)
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.Material = Enum.Material.Neon
                    part.Color = DefaultColor
                end
            end
        end
        
        -- Function to shift colors over time (if enabled)
        local function updateColors(character)
            if not ColorChangeEnabled then return end
            task.spawn(function()
                while character.Parent do
                    local newColor = Color3.fromRGB(math.random(200, 255), 0, 0) -- Varying shades of bright red
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") and part.Material == Enum.Material.Neon then
                            part.Color = newColor
                        end
                    end
                    task.wait(ColorChangeInterval)
                end
            end)
        end
        
        -- Function to handle new characters
        local function onCharacterAdded(character, player)
            if not ApplyToSelf and player == Players.LocalPlayer then return end
            removeClothes(character)
            applyNeonEffect(character)
            updateColors(character)
        end
        
        -- Apply effect to all current players
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Character then
                onCharacterAdded(player.Character, player)
            end
            player.CharacterAdded:Connect(function(character)
                onCharacterAdded(character, player)
            end)
        end
        
        -- Apply effect to new players
        Players.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Connect(function(character)
                onCharacterAdded(character, player)
            end)
        end)
        
    end,
 })

 local Section = con:CreateSection("Triggerbot Config")

 TRTEAMCHECK = TRUE
delayTime = 0.1

 local Slider = con:CreateSlider({
    Name = "Trigger Bot Delay",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "Milliseconds",
    CurrentValue = 0.1,
    Flag = "Slider4", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
delayTime = Value
    end,
 })


 local Toggle = con:CreateToggle({
    Name = "Trigger bot teamcheck",
    CurrentValue = true,
    Flag = "Toggle14", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
TRTEAMCHECK = Value
    end,
 })

 local Section = con:CreateSection("Aimbot Config")

FovTRCon = 0.5

 local Slider = con:CreateSlider({
    Name = "Fov circle transparency",
    Range = {0.01, 1},
    Increment = 0.01,
    Suffix = "transparency",
    CurrentValue = 0.5,
    Flag = "Slider6", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
FovTRCon = Va
    end,
 })

 AimkeyCon = Enum.UserInputType.MouseButton2 -- Default aim key

 local Dropdown = con:CreateDropdown({
    Name = "Aim Key",
    Options = {
        "Right Mouse Button",  -- MouseButton2
        "Left Mouse Button",   -- MouseButton1
        "Middle Mouse Button", -- MouseButton3
        "Left Shift",          -- Keyboard LShift
        "E Key"               -- Keyboard E
    },
    CurrentOption = {"Right Mouse Button"}, -- Default option
    MultipleOptions = false,
    Flag = "Dropdown1", -- Unique flag for config saving
    Callback = function(Options)
        -- Map selected option to Enum values
        local keyMappings = {
            ["Right Mouse Button"] = Enum.UserInputType.MouseButton2,
            ["Left Mouse Button"] = Enum.UserInputType.MouseButton1,
            ["Middle Mouse Button"] = Enum.UserInputType.MouseButton3,
            ["Left Shift"] = Enum.KeyCode.LeftShift,
            ["E Key"] = Enum.KeyCode.E
        }
 
        AimkeyCon = keyMappings[Options] or Enum.UserInputType.MouseButton2 -- Fallback to default
    end,
 })

FovIsVisible = 0 -- Default state

local Toggle = con:CreateToggle({
   Name = "Fov Visibilty",
   CurrentValue = false,
   Flag = "Toggle16", -- Ensure a unique flag for config saving
   Callback = function(Value)
       FovIsVisible = Value and 1 or 0 -- Sets to 1 if true, otherwise 0
   end,
})


-- Global variable to store the smoothing value
editfov = 60  -- This is now a global variable
AIMTEAMCHECK = true
FOVColor = Color3.new(1, 0, 0)
-- Slider to control the aimbot smoothing
local Slider = con:CreateSlider({
    Name = "Aimbot Fov",
    Range = {10, 300},
    Increment = 1,
    Suffix = "degrees",
    CurrentValue = 60,
    Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        -- Update the global variable `smoothness` whenever the slider changes
        editfov = Value
        print("Smoothness updated to:", smoothness)  -- Optional: Print the new value for debugging
    end,
})

 smoothness = 1
 -- Slider for Smoothness
 local SmoothnessSlider = con:CreateSlider({
     Name = "Aimbot Smoothness",
     Range = {0.9, 1},  -- Smoothness range from 0 (instant) to 1 (slower)
     Increment = 0.01,  -- Small increment to adjust smoothness
     Suffix = "Higher is faster",  -- Label for the value
     CurrentValue = 1,  -- Default value from aimbot settings
     Flag = "Slider2",  -- Identifier for saving configuration
     Callback = function(Value)
         -- Update the smoothness setting based on slider value
         smoothness = Value
     end,
 })

AIMVISIBILITYCHECK = false

 local Toggle = con:CreateToggle({
    Name = "Aimbot visibilty check",
    CurrentValue = false,
    Flag = "Toggle23", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
AIMVISIBILITYCHECK = Value
    end,
 })

 local Toggle = con:CreateToggle({
    Name = "Aimbot teamcheck",
    CurrentValue = true,
    Flag = "Toggle15", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
TRTEAMCHECK = Value 
    end,
 })

-- Declare FOVColor at a higher scope
FOVCconfig = Color3.new(1, 0, 0) -- Default red

local ColorPicker = con:CreateColorPicker({
    Name = "Fov color",
    Color = FOVColor, -- Use the current value for initial color
    Flag = "ColorPicker1", -- Unique flag for config saving
    Callback = function(Value)
        FOVCconfig = Value  -- Update the FOVColor variable with the chosen color
        print("FOVColor updated to:", FOVColor) -- Debug print to confirm update
    end
})

local Section = con:CreateSection("Snaplines config")

RainbowSnaplineC = false

local Toggle = con:CreateToggle({
    Name = "Rainbow snaplines",
    CurrentValue = false,
    Flag = "Toggle21", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
RainbowSnaplineC = Value
    end,
 })

SnaplineRainbowC = 3

 local Slider = con:CreateSlider({
    Name = "Snapline Rainbow speed",
    Range = {0.2, 10},
    Increment = 0.2,
    Suffix = "Seconds",
    CurrentValue = 3,
    Flag = "Slider12", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
SnaplineRainbowC = Value
    end,
 })

SnaplinesCconfig = Color3.new(0, 1, 0) -- Default red

local ColorPicker = con:CreateColorPicker({
    Name = "Snaplines color",
    Color = SnaplinesCconfig, -- Use the current value for initial color
    Flag = "ColorPicker2", -- Unique flag for config saving
    Callback = function(Value)
        SnaplinesCconfig = Value  -- Update the FOVColor variable with the chosen color
        print("FOVColor updated to:", SnaplinesCconfig) -- Debug print to confirm update
    end
})


local Section = con:CreateSection("Health config")

HealthEspColorCon = Color3.new(0, 1, 0)

local ColorPicker = con:CreateColorPicker({
    Name = "Health esp color",
    Color = HealthEspColorCon,
    Flag = "ColorPicker3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
HealthEspColorCon = Value
    end
})

local Section = con:CreateSection("Chams")

chamscolor = Color3.fromRGB(255, 0, 0)

local ColorPicker = con:CreateColorPicker({
    Name = "Chams color",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = "ColorPicker4", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
chamscolor = Value
    end
})

rainbowchams = false

local Toggle = con:CreateToggle({
    Name = "Rainbow chams",
    CurrentValue = false,
    Flag = "Toggle19", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
rainbowchams = Value
    end,
 })

rainbowspeed = 3

 local Slider = con:CreateSlider({
    Name = "Rainbow speed",
    Range = {0.2, 10},
    Increment = 0.2,
    Suffix = "Seconds",
    CurrentValue = 3,
    Flag = "Slider12", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
rainbowspeed = Value
    end,
 })

selfchams = false

 local Toggle = con:CreateToggle({
    Name = "Apply chams on self",
    CurrentValue = false,
    Flag = "Toggle20", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
selfchams = Value
    end,
 })


 local Section = con:CreateSection("Silent Aim")


silent_aim_fov = 100
silent_aim_checksight = true
silent_aim_fov_enabled = true
silent_aim_fov_color = Color3.fromRGB(255, 0, 0)

local Slider = con:CreateSlider({
    Name = "SilentAim Fov Circle radius",
    Range = {5, 300},
    Increment = 1,
    Suffix = "degrees",
    CurrentValue = 100,
    Flag = "Slider20", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        silent_aim_fov = Value
    end,
 })

 local Toggle = con:CreateToggle({
    Name = "Visible Check",
    CurrentValue = false,
    Flag = "Toggle31", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
silent_aim_checksight = Value
    end,
 })

 local Toggle = con:CreateToggle({
    Name = "Fov Enabled",
    CurrentValue = false,
    Flag = "Toggle32", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
silent_aim_fov_enabled = Value
    end,
 })

 local ColorPicker = con:CreateColorPicker({
    Name = "Fov Color",
    Color = Color3.fromRGB(255,255,255),
    Flag = "ColorPicker9", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
silent_aim_fov_color = Value
    end
})

 local Toggle = aim:CreateToggle({
    Name = "Silent Aim",
    CurrentValue = false,
    Flag = "Toggle30", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
--[[
Aim Script Modification for Roblox Game (Snap-on-Fire Aim Assist - NO HOOKING - OPTIMIZED + TOGGLE MODE + FOV + CROSSHAIR CHECK)

Goal:
- Toggleable Assist Mode for LMB Snap-on-Fire.
- Optimized hitbox management.
- NEW: Toggleable visual FOV circle.
- NEW: Optional check requires crosshair to be near target (within FOV circle) to activate snap.

Features:
- Toggle Key (TOGGLE_MODE_KEY) -> isAssistModeActive
- Fire Key (FIRE_KEY) + Assist Mode Active -> Snap Logic
- Hitbox Caching & Dynamic Updates
- FOV Circle GUI (ENABLE_FOV_CIRCLE, FOV_RADIUS)
- Crosshair Trigger Check (ENABLE_CROSSHAIR_TRIGGER_CHECK, uses FOV_RADIUS)
]]

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService") -- For inset calculation
local CoreGui = game:GetService("CoreGui") -- For placing GUI

-- Configuration
local HITBOX_NAME = "HitboxHeadSmall"
local FIRE_KEY = Enum.UserInputType.MouseButton1 -- Key to PRESS to trigger the snap+fire (when mode is active)
local TOGGLE_MODE_KEY = Enum.KeyCode.RightControl -- Key to TOGGLE Assist Mode ON/OFF
local ASSIST_MODE_ACTIVE_BY_DEFAULT = false     -- Should Assist Mode be active when the script loads?

local MAX_DISTANCE_3D = 300 -- Max 3D distance to find targets
local CHECK_LINE_OF_SIGHT = silent_aim_checksight -- Recommended: Only aim if target is visible

-- NEW: FOV Circle & Crosshair Check Config
local ENABLE_FOV_CIRCLE = silent_aim_fov_enabled           -- Show the visual FOV circle?
local FOV_RADIUS = silent_aim_fov                   -- Radius of the circle in screen pixels. Also used for Crosshair Check.
local FOV_CIRCLE_COLOR = silent_aim_fov_color -- Red
local FOV_CIRCLE_THICKNESS = 1           -- Thickness of the circle line
local FOV_CIRCLE_SIDES = 32              -- How many segments for the circle frame (higher = smoother)
local ENABLE_CROSSHAIR_TRIGGER_CHECK = true -- Require crosshair within FOV radius of target to snap?

-- State
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local hitboxes = {}              -- Dictionary Set: { [hitboxInstance] = true }
local isAssistModeActive = ASSIST_MODE_ACTIVE_BY_DEFAULT
local isSnapping = false
local originalCameraCFrame = nil

-- GUI State
local fovGui = nil
local fovCircleFrame = nil

-- Connections Holder
local connections = {}

-- Debug print helper
local function debugPrint(...)
    print("[SnapAim Full Debug]:", ...)
end

-- === GUI Management ===

local function destroyFovGui()
    if fovGui then
        pcall(function() fovGui:Destroy() end)
        fovGui = nil
        fovCircleFrame = nil
        debugPrint("FOV GUI destroyed.")
    end
end

local function createOrUpdateFovGui()
    if not ENABLE_FOV_CIRCLE then
        destroyFovGui()
        return
    end

    if not fovGui or not fovGui.Parent then
        destroyFovGui() -- Clean up any remnants

        fovGui = Instance.new("ScreenGui")
        fovGui.Name = "FovCircleGui_" .. tostring(math.random(1, 10000))
        fovGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Or Global if needed over other CoreGuis
        fovGui.DisplayOrder = 1000 -- High display order to be on top
        fovGui.ResetOnSpawn = false
        fovGui.IgnoreGuiInset = true -- Cover entire screen space

        fovCircleFrame = Instance.new("Frame")
        fovCircleFrame.Name = "FovCircle"
        fovCircleFrame.AnchorPoint = Vector2.new(0.5, 0.5) -- Center anchor
        fovCircleFrame.Position = UDim2.fromScale(0.5, 0.5) -- Center position
        fovCircleFrame.Size = UDim2.fromOffset(FOV_RADIUS * 2, FOV_RADIUS * 2) -- Diameter
        fovCircleFrame.BackgroundTransparency = 1 -- Make frame background invisible

        local uiCorner = Instance.new("UICorner")
        uiCorner.CornerRadius = UDim.new(1, 0) -- Make it a perfect circle
        uiCorner.Parent = fovCircleFrame

        local uiStroke = Instance.new("UIStroke")
        uiStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        uiStroke.Color = FOV_CIRCLE_COLOR
        uiStroke.Thickness = FOV_CIRCLE_THICKNESS
        uiStroke.LineJoinMode = Enum.LineJoinMode.Round -- Smoother look
        uiStroke.Parent = fovCircleFrame

        fovCircleFrame.Parent = fovGui
        fovGui.Parent = CoreGui -- Place in CoreGui for better reliability in exploits

        debugPrint("FOV GUI created.")
    end

    -- Update visibility based on assist mode
    fovGui.Enabled = isAssistModeActive

    -- Ensure properties are up-to-date (useful if config changes dynamically later)
    if fovCircleFrame then
        fovCircleFrame.Size = UDim2.fromOffset(FOV_RADIUS * 2, FOV_RADIUS * 2)
        local uiStroke = fovCircleFrame:FindFirstChildOfClass("UIStroke")
        if uiStroke then
            uiStroke.Color = FOV_CIRCLE_COLOR
            uiStroke.Thickness = FOV_CIRCLE_THICKNESS
        end
    end
end


-- === Target Management Functions (Mostly Unchanged, added helper) ===

local function isAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

local function addHitbox(hitbox)
    if hitbox and hitbox:IsA("BasePart") and hitbox.Name == HITBOX_NAME then
        local char = hitbox:FindFirstAncestorOfClass("Model")
        if char and char ~= LocalPlayer.Character and isAlive(char) then
             if not hitboxes[hitbox] then hitboxes[hitbox] = true; return true end
        end
    end return false
end

local function removeHitbox(hitbox)
     if hitboxes[hitbox] then hitboxes[hitbox] = nil; return true end
     return false
end

local function onCharacterAdded(character)
    if not character then return end; task.wait(0.5)
    if not character or not character.Parent then return end
    local headHitbox = character:FindFirstChild(HITBOX_NAME, true)
    if headHitbox and addHitbox(headHitbox) then
         local ancestryConn, deathConn
         ancestryConn = headHitbox.AncestryChanged:Connect(function(_, parent) if not parent or not headHitbox:IsDescendantOf(Workspace) then removeHitbox(headHitbox); if ancestryConn then pcall(ancestryConn.Disconnect, ancestryConn) end; if deathConn then pcall(deathConn.Disconnect, deathConn) end end end)
         local humanoid = character:FindFirstChildOfClass("Humanoid")
         if humanoid then deathConn = humanoid.Died:Connect(function() removeHitbox(headHitbox); if deathConn then pcall(deathConn.Disconnect, deathConn) end; if ancestryConn then pcall(ancestryConn.Disconnect, ancestryConn) end end) end
    end
end

local function onCharacterRemoving(character) if not character then return end; for hitboxInstance, _ in pairs(hitboxes) do if hitboxInstance:IsDescendantOf(character) then removeHitbox(hitboxInstance) end end end
local function initialCache() debugPrint("Performing initial hitbox cache..."); hitboxes = {}; local c = 0; local l = LocalPlayer.Character; for _, o in ipairs(Workspace:GetDescendants()) do if o.Name == HITBOX_NAME and o:IsA("BasePart") then local ch = o:FindFirstAncestorOfClass("Model"); if ch and ch ~= l and isAlive(ch) then if addHitbox(o) then c = c + 1 end end end end; debugPrint("Initial cache complete. Found:", c, "hitboxes.") end
local function setupDynamicHandlers() for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then if p.Character then onCharacterAdded(p.Character) end; table.insert(connections, p.CharacterAdded:Connect(onCharacterAdded)); table.insert(connections, p.CharacterRemoving:Connect(onCharacterRemoving)) end end; table.insert(connections, Players.PlayerAdded:Connect(function(p) table.insert(connections, p.CharacterAdded:Connect(onCharacterAdded)); table.insert(connections, p.CharacterRemoving:Connect(onCharacterRemoving)) end)); table.insert(connections, Players.PlayerRemoving:Connect(function(p) if p.Character then onCharacterRemoving(p.Character) end end)); table.insert(connections, Workspace.DescendantAdded:Connect(function(d) if d.Name == HITBOX_NAME and d:IsA("BasePart") then task.delay(0.1, function() if d and d.Parent then addHitbox(d) end end) end end)); table.insert(connections, Workspace.DescendantRemoving:Connect(function(d) if d.Name == HITBOX_NAME and d:IsA("BasePart") then removeHitbox(d) end end)); debugPrint("Dynamic hitbox handlers setup.") end

initialCache()
setupDynamicHandlers()

-- === Target Finding Functions (Added screen position check) ===

-- Helper to check if a 3D point is within the FOV circle on screen
local function isPointInFovCircle(point3D)
    if not Camera then return false end
    local screenPos, onScreen = Camera:WorldToScreenPoint(point3D)
    if not onScreen then return false end -- Target behind camera or too far

    local mousePos = UserInputService:GetMouseLocation() -- Using actual mouse pos as center reference
    -- Adjust mouse pos for GuiInset if not IgnoreGuiInset
    -- local guiInset = GuiService:GetGuiInset()
    -- local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Alternative center

    local distFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distFromCenter <= FOV_RADIUS
end

local function checkLineOfSightOptimized(targetPart, cameraPos)
    local localChar = LocalPlayer.Character; if not localChar or not targetPart.Parent then return false end
    local targetPos = targetPart.Position; local direction = (targetPos - cameraPos).Unit
    local origin = cameraPos + direction * 0.1; local distance = (targetPos - origin).Magnitude
    if distance < 0.1 then return true end
    local params = RaycastParams.new(); params.FilterType = Enum.RaycastFilterType.Exclude
    local filterList = {localChar}; local targetChar = targetPart:FindFirstAncestorOfClass("Model")
    if targetChar then table.insert(filterList, targetChar) end
    params.FilterDescendantsInstances = filterList; params.IgnoreWater = true
    return not Workspace:Raycast(origin, direction * distance, params)
end

local function findClosestTargetOptimized()
    local bestTarget = nil
    local minDist3D = MAX_DISTANCE_3D -- Check 3D distance
    local closestScreenDist = FOV_RADIUS -- Check screen distance relative to mouse

    local cameraPos = Camera and Camera.CFrame.Position
    local mousePos = UserInputService:GetMouseLocation()
    if not cameraPos then return nil end

    for hitboxInstance, _ in pairs(hitboxes) do
        if hitboxInstance and hitboxInstance.Parent then
            local targetPos3D = hitboxInstance.Position
            local dist3D = (targetPos3D - cameraPos).Magnitude

            -- Check 3D Distance First
            if dist3D <= minDist3D and dist3D > 0.1 then
                -- Check if On Screen and within FOV Radius
                 local screenPos, onScreen = Camera:WorldToScreenPoint(targetPos3D)
                 if onScreen then
                     local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                     if screenDist <= closestScreenDist then
                         -- Check Line of Sight (most expensive, do last)
                         if CHECK_LINE_OF_SIGHT then
                            if checkLineOfSightOptimized(hitboxInstance, cameraPos) then
                                -- Found a potentially better target
                                bestTarget = hitboxInstance
                                closestScreenDist = screenDist -- Prioritize target closest to crosshair within FOV
                                -- We could also use minDist3D here if preferred priority is 3D distance
                            end
                         else
                             -- No LoS check needed, update best target
                             bestTarget = hitboxInstance
                             closestScreenDist = screenDist
                         end
                     end
                 end
            end
        else
            removeHitbox(hitboxInstance) -- Housekeeping
        end
    end
    return bestTarget
end


-- === Input Handling (Added Crosshair Trigger Check) ===

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == TOGGLE_MODE_KEY then
        isAssistModeActive = not isAssistModeActive
        debugPrint("Assist Mode Toggled:", isAssistModeActive and "ACTIVE" or "INACTIVE")
        createOrUpdateFovGui() -- Update GUI visibility
        if not isAssistModeActive then isSnapping = false; originalCameraCFrame = nil end
        return
    end

    if not isAssistModeActive then return end

    if input.UserInputType == FIRE_KEY then
        debugPrint("Fire key pressed while Assist Mode is ACTIVE.")
        local targetToSnap = findClosestTargetOptimized()

        if targetToSnap and Camera then
             local proceedWithSnap = true -- Assume true initially

             -- ** NEW: Crosshair Trigger Check **
            if ENABLE_CROSSHAIR_TRIGGER_CHECK then
                local targetScreenPos, onScreen = Camera:WorldToScreenPoint(targetToSnap.Position)
                 local mousePos = UserInputService:GetMouseLocation()
                 if onScreen then
                     local dist = (Vector2.new(targetScreenPos.X, targetScreenPos.Y) - mousePos).Magnitude
                    if dist > FOV_RADIUS then
                        debugPrint("Snap cancelled: Crosshair too far from target (Dist: " .. string.format("%.1f", dist) .. ")")
                        proceedWithSnap = false
                    end
                 else
                     debugPrint("Snap cancelled: Target not on screen (somehow passed initial check?).")
                    proceedWithSnap = false -- Should not happen if findClosest handled it, but safe check
                 end
            end

            -- Proceed if check passed or is disabled
            if proceedWithSnap then
                debugPrint(string.format("Snapping aim to %s", targetToSnap:GetFullName()))
                isSnapping = true
                originalCameraCFrame = Camera.CFrame
                Camera.CFrame = CFrame.new(originalCameraCFrame.Position, targetToSnap.Position)

                task.spawn(function()
                    RunService.RenderStepped:Wait()
                    if isSnapping and isAssistModeActive and originalCameraCFrame and Camera then
                        Camera.CFrame = originalCameraCFrame
                    end
                    isSnapping = false
                    originalCameraCFrame = nil
                end)
            end
        else
            debugPrint("Fire key pressed, but no valid/visible target found within FOV/LoS.")
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    -- No specific actions needed on key release in this setup
end)

-- === Heartbeat / RenderStepped Loop (GUI Update) ===
table.insert(connections, RunService.RenderStepped:Connect(function(dt)
    -- Update FOV Circle Visibility/State if necessary
    if ENABLE_FOV_CIRCLE and fovGui then
        if fovGui.Enabled ~= isAssistModeActive then
            fovGui.Enabled = isAssistModeActive
            -- debugPrint("FOV GUI visibility updated:", isAssistModeActive) -- Optional: reduce spam
        end
    end

    -- Reset snapping state if mode is toggled off during the snap cycle
    if not isAssistModeActive and isSnapping then
        isSnapping = false
        originalCameraCFrame = nil
    end
end))

-- === Cleanup Function ===
local function cleanup()
    debugPrint("Cleaning up SnapAim script...")
    destroyFovGui() -- Destroy GUI elements
    for _, connection in ipairs(connections) do
        pcall(connection.Disconnect, connection)
    end
    connections = {}
    hitboxes = {}
    debugPrint("Cleanup complete.")
end
-- Connect cleanup if possible: -- script.Destroying:Connect(cleanup)

-- Initial Status Message & GUI Setup
debugPrint("Optimized Snap-on-Fire Aim Assist script loaded.")
debugPrint("Assist Mode Status:", isAssistModeActive and "ACTIVE" or "INACTIVE")
debugPrint("Press [" .. TOGGLE_MODE_KEY.Name .. "] to toggle Assist Mode.")
debugPrint("FOV Circle:", ENABLE_FOV_CIRCLE and "Enabled" or "Disabled", "(Radius: " .. FOV_RADIUS .. ")")
debugPrint("Crosshair Trigger Check:", ENABLE_CROSSHAIR_TRIGGER_CHECK and "Enabled" or "Disabled")
debugPrint("When Assist Mode is ACTIVE, press [" .. FIRE_KEY.Name .. "] to fire with snap assist.")
createOrUpdateFovGui() -- Create the GUI initially based on default state
    end,
 })
